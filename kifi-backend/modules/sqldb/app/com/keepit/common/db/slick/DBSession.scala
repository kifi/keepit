package com.keepit.common.db.slick

import java.sql._
import scala.collection.mutable
import scala.slick.session.{Session, ResultSetConcurrency, ResultSetType, ResultSetHoldability }
import scala.concurrent._
import scala.util.Try

import play.api.Logger
import com.keepit.common.time._
import java.util.concurrent.Executor
import java.{util, sql}
import java.util.Properties
import scala.Some
import scala.Array

class ConnectionWrapper(conn: Connection) extends Connection {
  def createStatement(): Statement = conn.createStatement()
  def prepareStatement(sql: String): PreparedStatement = conn.prepareStatement(sql)
  def prepareCall(sql: String): CallableStatement = conn.prepareCall(sql)

  def nativeSQL(sql: String): String = ???

  def setAutoCommit(autoCommit: Boolean): Unit = ???

  def getAutoCommit: Boolean = ???

  def commit(): Unit = ???

  def rollback(): Unit = ???

  def close(): Unit = ???

  def isClosed: Boolean = ???

  def getMetaData: DatabaseMetaData = ???

  def setReadOnly(readOnly: Boolean): Unit = ???

  def isReadOnly: Boolean = ???

  def setCatalog(catalog: String): Unit = ???

  def getCatalog: String = ???

  def setTransactionIsolation(level: Int): Unit = ???

  def getTransactionIsolation: Int = ???

  def getWarnings: SQLWarning = ???

  def clearWarnings(): Unit = ???

  def createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement = ???

  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement = ???

  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement = ???

  def getTypeMap: util.Map[String, Class[_]] = ???

  def setTypeMap(map: util.Map[String, Class[_]]): Unit = ???

  def setHoldability(holdability: Int): Unit = ???

  def getHoldability: Int = ???

  def setSavepoint(): Savepoint = ???

  def setSavepoint(name: String): Savepoint = ???

  def rollback(savepoint: Savepoint): Unit = ???

  def releaseSavepoint(savepoint: Savepoint): Unit = ???

  def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement = ???

  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement = ???

  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): CallableStatement = ???

  def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = ???

  def prepareStatement(sql: String, columnIndexes: Array[Int]): PreparedStatement = ???

  def prepareStatement(sql: String, columnNames: Array[String]): PreparedStatement = ???

  def createClob(): Clob = ???

  def createBlob(): Blob = ???

  def createNClob(): NClob = ???

  def createSQLXML(): SQLXML = ???

  def isValid(timeout: Int): Boolean = ???

  def setClientInfo(name: String, value: String): Unit = ???

  def setClientInfo(properties: Properties): Unit = ???

  def getClientInfo(name: String): String = ???

  def getClientInfo: Properties = ???

  def createArrayOf(typeName: String, elements: Array[AnyRef]): sql.Array = ???

  def createStruct(typeName: String, attributes: Array[AnyRef]): Struct = ???

  def setSchema(schema: String): Unit = ???

  def getSchema: String = ???

  def abort(executor: Executor): Unit = ???

  def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = ???

  def getNetworkTimeout: Int = ???
}

object DBSession {
  abstract class SessionWrapper(val name: String, val masterSlave: Database.DBMasterSlave, _session: => Session) extends Session {
    private var open = false
    private var doRollback = false
    private var transaction: Option[Promise[Unit]] = None
    private var startTime: Long = -1
    lazy val session = {
      val s = _session
      if (inTransaction) s.conn.setAutoCommit(false)
      open = true
      startTime = System.currentTimeMillis
      s
    }
    lazy val clock = new SystemClock

    private def transactionFuture: Future[Unit] = {
      require(inTransaction, "Not in a transaction.")
      transaction.get.future
    }

    def conn: Connection = new ConnectionWrapper(session.conn)
    def metaData = session.metaData
    def capabilities = session.capabilities
    override def resultSetType = session.resultSetType
    override def resultSetConcurrency = session.resultSetConcurrency
    override def resultSetHoldability = session.resultSetHoldability

    private val dbLog = Logger("com.keepit.db")

    def close(): Unit = if (open) {
      session.close()
      val time = System.currentTimeMillis - startTime
      dbLog.info(s"t:${clock.now}\ttype:SESSION\tduration:${time}\tname:$name\ttype:$masterSlave")
    }

    def rollback() { doRollback = true }
    def inTransaction = transaction.nonEmpty

    def onTransactionSuccess[U](f: => U)(implicit executor: ExecutionContext): Unit = transactionFuture.onSuccess { case _: Unit => f }
    def onTransactionFailure [U](f: PartialFunction[Throwable, U])(implicit executor: ExecutionContext): Unit = transactionFuture.onFailure(f)
    def onTransactionComplete[U](f: Function[Try[Unit], U])(implicit executor: ExecutionContext): Unit = transactionFuture.onComplete(f)

    def withTransaction[T](f: => T): T = if (inTransaction) f else {
      if (open) conn.setAutoCommit(false)
      transaction = Some(Promise())
      try {
        var done = false
        try {
          val res = f
          done = true
          res
        } finally {
          if (open && !done || doRollback) {
            conn.rollback()
            transaction.get.failure(new Exception("Transaction was rolled back."))
          } else transaction.get.success()
        }
      } finally {
        if (open) conn.setAutoCommit(true)
        transaction = None
      }
    }

    private val statementCache = new mutable.HashMap[String, PreparedStatement]
    def getPreparedStatement(statement: String): PreparedStatement = {
      if(true) throw new Exception("meeeeee")
      val preparedStatement = statementCache.getOrElseUpdate(statement, {
        val newPreparedStatement = this.conn.prepareStatement(statement)
        println(s"t:${clock.now}\ttype:NEW_PRP_STMT\tcacheSize:${statementCache.size}\tVALUE:$statement")
        newPreparedStatement
      })
      println(s"t:${clock.now}\ttype:USE_PRP_STMT\tVALUE:$statement")
      preparedStatement
    }

    override def forParameters(rsType: ResultSetType = resultSetType, rsConcurrency: ResultSetConcurrency = resultSetConcurrency,
      rsHoldability: ResultSetHoldability = resultSetHoldability) =
        _session.forParameters(rsType, rsConcurrency, rsHoldability)
  }

  abstract class RSession(name: String, masterSlave: Database.DBMasterSlave, roSession: => Session) extends SessionWrapper(name, masterSlave, roSession)
  class ROSession(masterSlave: Database.DBMasterSlave, roSession: => Session) extends RSession("RO", masterSlave, roSession)
  class RWSession(rwSession: => Session) extends RSession("RW", Database.Master, rwSession) //RWSession is always reading from master

  implicit def roToSession(roSession: ROSession): Session = roSession
  implicit def rwToSession(rwSession: RWSession): Session = rwSession
}
